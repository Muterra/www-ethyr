<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>ethyr</title><link href="/blog/" rel="alternate"></link><link href="/blog/feeds/muse.atom.xml" rel="self"></link><id>/blog/</id><updated>2015-10-07T17:47:00-07:00</updated><entry><title>Muse overview</title><link href="/blog/muse-101.html" rel="alternate"></link><updated>2015-10-07T17:47:00-07:00</updated><author><name>Nick Badger</name></author><id>tag:,2015-10-07:blog/muse-101.html</id><summary type="html">&lt;p&gt;Though this blog is primarily focused on Ethyr, the Muse protocol is the technical meat and bones of this project. It is Ethyr's primary innovation and Muterra's core technology. As such, this blog is also a convenient place to talk about the protocol itself. What follows is a brief exploration thereof.&lt;/p&gt;
&lt;h2&gt;Muse&lt;/h2&gt;
&lt;p&gt;The abstract intent of the Muse protocol is deceptively simple. Imagine you've created some digital work: a quick text explanation of a project you're working on, for example. Now you'd like to share it with someone. Muse is designed to handle the sharing step as directly as possible, without requiring websites as middlemen - all while still ensuring that only your intended recipient(s) have access to the data. The goal is to make the actual process of sharing something as simple and exact as it seems it should be.&lt;/p&gt;
&lt;p&gt;It's worth noting that this bears a large resemblance to email in the early 2000's, when it was already quite popular, but most people only had a single address. If you wanted to share something with someone digitally, you sent them an email. It was easy and effective. But email (at least as we usually see it) is severely limited: it's &lt;a href="https://en.wikipedia.org/wiki/Email#Privacy_concerns"&gt;wholly insecure&lt;/a&gt;, incompatible with &lt;a href="https://en.wikipedia.org/wiki/Many-to-many"&gt;publication&lt;/a&gt;, slow, and awkward for everything except text. In contrast, Muse behaves like a modernized version of &lt;a href="https://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol"&gt;SMTP&lt;/a&gt;: it's encrypted, supports publicly-viewable data, is real-time capable, and works for any and all digital information.&lt;/p&gt;
&lt;p&gt;In other words, imagine a new version of email designed specifically for encrypted social networking. That means one-to-any support at a protocol level: you can "address" the "message" to any number of people, even the general public, or nobody. Muse accomplishes this by separating message delivery into the discrete concerns of &lt;a href="https://en.wikipedia.org/wiki/Persistent_memory"&gt;persistence&lt;/a&gt; and sharing. The message itself is encrypted at all times, and it can be "delivered" without a trusted server, because access sharing takes place directly between network participants. Note that, as participants may not have a 1-to-1 relationship with devices, this is a subtly different consideration than traditional &lt;a href="https://en.wikipedia.org/wiki/End-to-end_encryption"&gt;end-to-end encryption&lt;/a&gt;. And unlike email, Muse is not strictly an internet protocol: it is designed to work with any data connection between network peers. Muse is therefore not only capable of fluid transition to alternative network infrastructure (for example, a &lt;a href="http://www.bluetooth.com/Pages/Press-Releases-Detail.aspx?ItemID=224"&gt;Bluetooth mesh network&lt;/a&gt;), but also fully compatible with existing technologies like Websockets or WebRTC. And also unlike email, with its clumsy binary -&amp;gt; text -&amp;gt; ascii-armor transition for binary attachments, Muse is a natively binary protocol.&lt;/p&gt;
&lt;h2&gt;Protocol goals&lt;/h2&gt;
&lt;p&gt;Before discussing protocol technical requirements, I'd like to stress a few key points. Muse is a &lt;strong&gt;protocol&lt;/strong&gt;: not a platform, not a product. To use it, someone needs to write a protocol implementation. Though Muse is an openly-published protocol, implementations may be closed source. Furthermore, though the Muse &lt;em&gt;protocol&lt;/em&gt; is not married to any one data transport technology, Muse &lt;em&gt;implementations&lt;/em&gt; likely will be. Part of the hope here is to free social applications from data transport concerns and make them wholly network agnostic (and vice versa); this approach requires the implementations themselves to exclusively handle physical data delivery, and the applications to only handle information use. &lt;/p&gt;
&lt;p&gt;This greatly simplifies network innovation and enables application-independent, seamless transition between &lt;a href="https://en.wikipedia.org/wiki/Internet_protocol_suite"&gt;various&lt;/a&gt; &lt;a href="https://en.wikipedia.org/wiki/Tor_%28anonymity_network%29"&gt;different&lt;/a&gt; &lt;a href="https://en.wikipedia.org/wiki/Private_network"&gt;networking&lt;/a&gt; &lt;a href="https://en.wikipedia.org/wiki/MaidSafe"&gt;technologies&lt;/a&gt;. However, it also begets an important caveat: Muse's security is always beholden to the underlying transport layer. It is up to that transport layer and its Muse implementation to address network-level security risks, such as traffic analysis or hard IP address anonymity.&lt;/p&gt;
&lt;p&gt;At the other end of the Muse abstraction, the protocol also has limits. Though it stresses granting network &lt;a href="https://en.wikipedia.org/wiki/Agency_%28philosophy%29"&gt;agency&lt;/a&gt; to abstract digital "identities" instead of concrete physical devices, Muse does not concern itself with the specifics of those identities. They are the &lt;a href="https://en.wikipedia.org/wiki/Key_exchange"&gt;absolute minimum that is technically required by the protocol&lt;/a&gt;, and do not offer any inherent assertion or identity ownership. Such verification requirements are always application-specific, so the Muse protocol deliberately avoids them. All Muse-based applications may make use of any Muse identity, regardless of (or contingent upon) any identity verification. Storage container formats (even for Muse primitives like identity &lt;a href="https://en.wikipedia.org/wiki/Public-key_cryptography"&gt;public keys&lt;/a&gt;) are similarly out-of-scope; standardizing core implementation functionality will be independently approached with Muse overlay standards proposals.&lt;/p&gt;
&lt;p&gt;That being said, any application making use of any Muse implementation can expect:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Private, encrypted information transfer directly between explicitly-addressed parties with no trusted third party, over&lt;/li&gt;
&lt;li&gt;An &lt;a href="https://en.wikipedia.org/wiki/Asynchronous_communication#Electronically_mediated_communication"&gt;asynchronously&lt;/a&gt;-available &lt;a href="https://en.wikipedia.org/wiki/Persistent_memory"&gt;persistence system&lt;/a&gt; with indefinite storage capability, using&lt;/li&gt;
&lt;li&gt;Identity-based communication addressing (and therefore implying full device and network independence), with&lt;/li&gt;
&lt;li&gt;Implementation-specific delivery speeds, up to and including real-time, and&lt;/li&gt;
&lt;li&gt;Implementation-specific traffic capacity.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Up next: the vision behind Ethyr.&lt;/strong&gt;&lt;/p&gt;</summary><category term="Muse"></category><category term="Technical"></category><category term="Implementation"></category></entry></feed>